\name{mcRun}
\alias{mcRun}
\title{Monte Carlo Simulation}
\usage{
  mcRun(mcr.fn, mcr.fnArgs = NULL, mcr.cluster = NULL,
    mcr.outfile = tempfile(fileext = ".csv"),
    mcr.datFn = NULL, mcr.datArgs = NULL, mcr.dat = NULL,
    mcr.constant = NULL, mcr.varying = NULL,
    mcr.LoadOnExit = TRUE, mcr.reportInt = 100)
}
\arguments{
  \item{mcr.fn}{A character string naming the function that
  performs the analysis: for example, for one-factor
  designs this could be any one of \code{\link{fitanova}},
  \code{\link{fitlmer}}, \code{\link{fitlmer.mcmc}},
  \code{\link{fitstepwise}},
  \code{\link{fitstepwise.bestpath}},
  \code{\link{fitrsonly}}, \code{\link{fitnocorr}}, or
  \code{\link{lrCompare}}.  May also be a user-supplied
  function (see 'Details').}

  \item{mcr.fnArgs}{Arguments to be passed from
  \code{mcRun} to the function named by \code{mcr.fn}.}

  \item{mcr.cluster}{A processing cluster object, typically
  created by a call to \code{makeCluster} from the package
  \code{parallel}.  If NULL (default), uses a single
  processing core.}

  \item{mcr.outfile}{name of file to which to write the
  output ("comma separated value" format).  Defaults to
  "out.csv".}

  \item{mcr.datFn}{Name of function to be used to generate
  data set for each Monte Carlo run (e.g., 'mkDf').  May be
  a user-supplied function that returns a data frame.  If a
  the same dataset is to be used for all runs, then set to
  'NULL' and define \code{mcr.dat} instead.}

  \item{mcr.datArgs}{Arguments to be passed from
  \code{mcRun} to the function named by \code{mcr.datFn}.}

  \item{mcr.dat}{A data frame to be used in all Monte Carlo
  runs.  If the data are to be generated by a function, set
  to 'NULL' and use \code{mcr.datFn} instead.}

  \item{mcr.constant}{list of parameter values that are
  constant over all runs.}

  \item{mcr.varying}{A matrix, data frame or list of lists
  containing the parameters to be varied over runs, with
  each row corresponding to a single run.  This determines
  the number of Monte Carlo runs (see 'Details').}

  \item{mcr.LoadOnExit}{whether the data should be loaded
  from the file upon completion into an R object, and
  passed on as the return value from the function.}

  \item{mcr.reportInt}{Interval at which to give status
  updates on progress (default = every 100 runs)}
}
\value{
  If mcr.LoadOnExit is true, loads the data from the CSV
  file and returns it to the calling function.
}
\description{
  Run Monte Carlo simulations, taking advantage of multiple
  processing cores or a computing cluster
}
\details{
  The number of simulations that will be run is given by
  \code{nrow(mcr.varying)}, the number of rows in the
  parameter matrix passed as an argument to the function.
  The results matrix will be stored in the file whose path
  is given by \code{mcr.outfile} in Comma Separated Values
  (CSV) format.

  If \code{mcr.fn} is a user-supplied function, the
  corresponding function must return a vector with all
  elements of mode 'numeric', and accept arguments
  \code{mcr.data} and (optionally) \code{mcr.params}.  All
  arguments in \code{mcr.fnList} will be passed to that
  function.

  If \code{mcr.datFn} is a user-supplied function, the
  corresponding function must return a data frame and
  accept the argument \code{mcr.params}. All arguments in
  \code{mcr.datArgs} will be passed to that function.
}
\examples{
nmc <- 10
pmx <- cbind(randParams(genParamRanges(), nmc, 1001), seed=mkSeeds(nmc, 1001))

cl <- NULL # single-core processing
# alternatively:
# cl <- parallel:::makeCluster(number.of.clusters)
# see the 'parallel' package

mx <- mcRun("fitanova", mcr.cluster=cl,
mcr.fnArgs=list(wsbi=TRUE), # pass this along to fitanova
mcr.varying=pmx, # parameters that are varying; each row is a single run
mcr.datFn="mkDf",  # data-generating function to call
mcr.datArgs=list(nitem=12, wsbi=TRUE), # values to be passed along to mkDf
mcr.reportInt=5) # report progress every 5 runs
}

