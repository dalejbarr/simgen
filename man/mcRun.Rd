\name{mcRun}
\alias{mcRun}
\title{
Monte Carlo Simulation
}
\description{
Run Monte Carlo simulations, taking advantage of multiple processing cores or a computing cluster
}
\usage{
mcRun(mcr.FUN, mcr.cluster=NULL, mcr.outfile=tempfile(fileext=".csv"), mcr.xdatFnc=NULL, mcr.xdat=NULL,
mcr.constant=NULL, mcr.varying=NULL, mcr.LoadOnExit=TRUE,
mcr.reportInt=100, ...)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{mcr.FUN}{
A character string naming the function that performs the analysis: one
of \code{\link{fitanova}}, \code{\link{fitlmer}}, \code{\link{fitlmer.mcmc}},
\code{\link{fitstepwise}}, \code{\link{fitstepwise.bestpath}},
\code{\link{fitrsonly}}, or \code{\link{fitnocorr}}.  May also be a
user-supplied function (see 'Details').
}
\item{mcr.cluster}{
  A processing cluster object, typically created by a call to
  \code{makeCluster} from the package \code{parallel}.  If NULL (default), just
  uses a single processing core.
  }
\item{mcr.outfile}{
  name of file to which to write the output ("comma separated value"
  format).  Defaults to "out.csv".
  }
  \item{mcr.xdatFnc}{
    Name of function to be used to generate data set for each Monte
    Carlo run (e.g., 'mkDf').  May be a user-supplied function that
    returns a data frame.  If a the same dataset is to be used for all runs, then
    set to 'NULL' and define \code{mcr.xdat} instead.
  }
  \item{mcr.xdat}{
    A data frame to be used in all Monte Carlo runs.  If the data are to
    be generated by a function, set to 'NULL' and use \code{mcr.xdatFnc} instead.
    }
  \item{mcr.constant}{
    list of parameter values that are constant over all runs.
  }
  \item{mcr.varying}{
    A matrix, data frame or (list of lists) containing the parameters to
    be varied over runs, with each row corresponding to a single run.
    This determines the number of Monte Carlo runs (see 'Details').
  }
  \item{mcr.LoadOnExit}{
    whether the data should be loaded from the file upon completion into
    an R object, and passed on as the return value from the function.
    }
  \item{mcr.reportInt}{
    Interval at which to give status updates on progress (default =
    every 100 runs)
  }
  \item{\dots}{
    Additional arguments to be passed to function named by 'mcr.xdatFnc'
    (e.g., mkDf or a user-supplied function) or 'mcr.FUN' (e.g., fitlmer, fitanova, etc., or a
    user-supplied function).
  }
}
\details{
The number of simulations that will be run is given by
\code{nrow(mcr.varying)}, the number of rows in the parameter matrix passed as an argument to the function.  The results matrix will be stored
in the file whose path is given by \code{mcr.outfile} in Comma Separated
Values (CSV) format.

If \code{mcr.FUN} is a user-supplied function, the corresponding function must
return a vector with all elements of mode 'numeric', and accept
arguments \code{mcr.data} and (optionally) \code{mcr.params}.  All
arguments matching the function call will be passed along by \code{mcRun}.

If \code{mcr.xdatFnc} is a user-supplied function, the corresponding
function must return a data frame and accept the argument
\code{mcr.params}.  All arguments matching the function call will be
passed along by \code{mcRun}.
}
\value{
If mcr.LoadOnExit is true, loads the data from the CSV file and returns it to the calling function.
}
%\seealso{
%\code{\link{fitlmer}}, \code{\link{fitanova}},
%\code{\link{fitlmer.mcmc}}, \code{\link{fitlmer.mselect}}.
%}
\examples{
pmx <- createParamMx(20, h0=TRUE)  # 20 experimental runs

cl <- parallel:::makeCluster(1) # single core processing
# if you have a multicore workstation, replace '1' with
# the number of cores you want to use

mx <- mcRun("fitanova", cl, 
mcr.outfile="out.csv", # save to out.csv
mcr.varying=pmx, # parameters that are varying
mcr.xdatFnc="mkDf",  # data-generating function to call
nitem=12, wsbi=TRUE, # values to be passed along to mkDf and fitanova
mcr.reportInt=5)
}

% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
% \keyword{ ~kwd1 }
% \keyword{ ~kwd2 }% __ONLY ONE__ keyword per line
